#Make datafile
library(LEA)
library(dartR)
setwd("/Users/ruthrivkin/Dropbox/Postdoc_2021-2024/Polar_Bears/Species_Dist_Modelling/Gradient_Forest/subset/")

infile <- "Subset.ld.hwe.raw"
myData <- read.PLINK(infile)
myData.nona <- gl.impute(myData, method = "neighbour")
myData.nona@pop
gl2structure(myData.nona, outpath = "/Volumes/OneTouch/PostDoc_2021-2025/ConStruct/")

conStruct.data <- structure2conStruct(infile = "/Volumes/OneTouch/PostDoc_2021-2025/ConStruct/gl.str.txt",
                                      onerowperind = FALSE,
                                      start.loci = 2,
                                      start.samples = 2,
                                      missing.datum = -9,
                                      outfile = "ld.myConStructData")


load("ld.myConStructData.RData")
freqs[1:5,1:10]
dim(freqs)

#Now switch to running construct on HPC, see construct.sh and construct-xval.sh for running the analyses.

#ConStruct
#switch back to R on computer to plot figures and interpret results

setwd("/Volumes/OneTouch/PostDoc_2021-2025/ConStruct/")

library(conStruct)

#Check xvals
#read in results from text files

#spatial results
sp.results <- as.matrix(
  read.table("xval2_sp_xval_results.txt",
             header = TRUE,
             stringsAsFactors = FALSE)
)

#non-spatial results
nsp.results <- as.matrix(
  read.table("xval2_nsp_xval_results.txt",
             header = TRUE,
             stringsAsFactors = FALSE)
)


# first, get the 95% confidence intervals for the spatial and nonspatial
#   models over values of K (mean +/- 1.96 the standard error)

sp.CIs <- apply(sp.results,1,function(x){mean(x) + c(-1.96,1.96) * sd(x)/length(x)})
nsp.CIs <- apply(nsp.results,1,function(x){mean(x) + c(-1.96,1.96) * sd(x)/length(x)})

# then, plot cross-validation results for K=1:3 with 8 replicates

par(mfrow=c(1,1))
plot(rowMeans(sp.results),
     pch=19,col="blue",
     ylab="predictive accuracy",xlab="values of K",
     ylim=range(sp.results,nsp.results),
     main="cross-validation results")
points(rowMeans(nsp.results),col="green",pch=19)

# finally, visualize results for the spatial model
#   separately with its confidence interval bars
#
# note that you could do the same with the spatial model, 
#   but the confidence intervals don't really show up 
#   because the differences between predictive accuracies
#   across values of K are so large.

plot(rowMeans(sp.results),
     pch=19,col="blue",
     ylab="predictive accuracy",xlab="values of K",
     ylim=range(sp.CIs),
     main="spatial cross-validation results")
segments(x0 = 1:nrow(sp.results),
         y0 = sp.CIs[1,],
         x1 = 1:nrow(sp.results),
         y1 = sp.CIs[2,],
         col = "blue",lwd=2)


t.test(sp.results[6,],sp.results[1,],paired=TRUE,alternative="greater")


#Check layers
# Loop through output files generated by conStruct 
#   runs with K=1 through 10 and calculate the 
#   layer contributions for each layer in each run  

layer.contributions <- matrix(NA,nrow=10,ncol=10)

# load the conStruct.results.Robj and data.block.Robj

#   files saved at the end of a conStruct run
load("pb.spatial.k1_data.block.Robj")
load("pb.spatial.k1_conStruct.results.Robj")

# calculate layer contributions
layer.contributions[,1] <- c(calculate.layer.contribution(conStruct.results[[1]],data.block),rep(0,9))
tmp <- conStruct.results[[1]]$MAP$admix.proportions

for(i in 2:10){
  # load the conStruct.results.Robj and data.block.Robj
  #   files saved at the end of a conStruct run
  load(sprintf("pb.spatial.k%s_conStruct.results.Robj",i))
  load(sprintf("pb.spatial.k%s_conStruct.results.Robj",i))
  
  # match layers up across runs to keep plotting colors consistent
  #   for the same layers in different runs
  tmp.order <- match.layers.x.runs(tmp,conStruct.results[[1]]$MAP$admix.proportions)  
  
  # calculate layer contributions
  layer.contributions[,i] <- c(calculate.layer.contribution(conStruct.results=conStruct.results[[1]],
                                                            data.block=data.block,
                                                            layer.order=tmp.order),
                               rep(0,10-i))
  tmp <- conStruct.results[[1]]$MAP$admix.proportions[,tmp.order]
}


#plot
barplot(layer.contributions,
        col=c("blue", "red", "yellow", "forestgreen", "darkorchid1", "lightblue", "pink","lightgreen", "orange", "grey"),
        xlab="",
        ylab="layer contributions",
        names.arg=paste0("K=",1:7))

#Hard to tell but k = 7 looks best between both comparisons?
#Plot figs


#K = 7
load("pb.spatial.k7_data.block.Robj")
load("pb.spatial.k7_conStruct.results.Robj")

# assign to new variable names
spk7_cr <- conStruct.results
spk7_db <- data.block


admix.props.k7 <- spk7_cr$chain_1$MAP$admix.proportions
make.structure.plot(admix.proportions = admix.props.k7)

# make an admix pie plot using the 
#   maximum a posteriori (MAP) estimates
#   from the first chain of a conStruct run


make.admix.pie.plot(admix.proportions = admix.props.k7,
                    coords = spk7_db$coords, radii = 1.5)


# add pie plot to an existing map
myCol <-c("blue", "red", "goldenrod1", "forestgreen", "darkorchid1", "lightblue", "pink")

# make the desired map
maps::map(xlim = range(spk7_db$coords[,1]) + c(-5,5), ylim = range(spk7_db$coords[,2])+c(-2,2), col="gray")

# add the admixture pie plot
plot(NULL, xlim = c(-140, -50), ylim = c(52, 85),
     xlab = "Longitude", ylab = "Latitude", main = "conStruct K = 7")
maps::map(add = T, interior = F, fill = T,col = "lightgrey" )

make.admix.pie.plot(admix.proportions = admix.props.k7,
                    coords = spk7_db$coords,
                    radii = 1.5,
                    add = TRUE,
                    layer.colors = myCol)


#Plot some other plots to evaluate model fit
#Define function 

#Plots model fit CIs
plot.model.fit.CIs <- function(data.block,conStruct.results){
  cov.range <- range(c(data.block$obsCov,
                       conStruct.results$posterior$par.cov))
  ut <- upper.tri(data.block$geoDist,diag=TRUE)
  graphics::plot(data.block$geoDist[ut],data.block$obsCov[ut],
                 xlab = "geographic distance", 
                 ylab = "covariance",
                 main="Cov/geoDist",
                 ylim = cov.range, type = "n")
  CIs <- apply(conStruct.results$posterior$par.cov,2:3,function(x){quantile(x,c(0.025,0.975))})
  invisible(
    lapply(1:data.block$N,
           function(i){
             lapply(i:data.block$N,
                    function(j){
                      graphics::segments(x0 = data.block$geoDist[i,j],
                                         y0 = CIs[1,i,j],
                                         x1 = data.block$geoDist[i,j],
                                         y1 = CIs[2,i,j],
                                         col = grDevices::adjustcolor(1,0.1),
                                         lwd=1.5)
                    })
           }))
  graphics::points(data.block$geoDist[ut],data.block$obsCov[ut],col=2,pch=20,cex=0.8)
  graphics::legend(x="topright",legend=c("observed","95% CI"),pch=c(19,NA),lty=c(NA,1),col=c(2,"gray"))
  return(invisible("plotted"))
}

plot.model.fit.CIs(spk2_db,spk2_cr[[1]])

#plot layer covariance
conStruct:::plot.layer.covariances

plot.layer.covariances <- function (data.block, conStruct.results, layer.colors, layer.order = NULL) 
{
  n.layers <- data.block$K
  if (is.null(layer.order)) {
    layer.order <- 1:n.layers
  }
  ind.mat <- upper.tri(data.block$geoDist, diag = TRUE)
  order.mat <- order(data.block$geoDist)
  y.range <- range(c(unlist(lapply(1:data.block$K, function(k) {
    conStruct.results$MAP$layer.params[[k]]$layer.cov
  })) + conStruct.results$MAP$gamma, data.block$obsCov))
  graphics::plot(data.block$geoDist[ind.mat], data.block$obsCov[ind.mat], 
                 xlim = range(data.block$geoDist), ylim = y.range, xlab = "geographic distance", 
                 ylab = "covariance", pch = 19, col = grDevices::adjustcolor(1, 
                                                                             0.7))
  lapply(1:data.block$K, function(k) {
    graphics::lines(data.block$geoDist[order.mat][ind.mat], 
                    conStruct.results$MAP$gamma + conStruct.results$MAP$layer.params[[layer.order[k]]]$layer.cov[order.mat][ind.mat], 
                    col = 1, lwd = 4.5, lty = 1)
    graphics::lines(data.block$geoDist[order.mat][ind.mat], 
                    conStruct.results$MAP$gamma + conStruct.results$MAP$layer.params[[layer.order[k]]]$layer.cov[order.mat][ind.mat], 
                    col = layer.colors[k], lwd = 4, lty = 1)
  })
  graphics::legend(x = "topright", col = layer.colors[1:data.block$K], 
                   lty = 1, legend = paste0("Layer_", 1:data.block$K), cex = 0.7)
  return(invisible("layer covs"))
}



plot.layer.covariances(spk7_db,spk7_cr[[1]], layer.colors = myCol)



#Check  phi (aka shared drift)in layers. If small, relatedness likely low

spk7_cr$chain_1$MAP$layer.params$layer_1$phi #5.663914e-05
spk7_cr$chain_1$MAP$layer.params$layer_2$phi #7.057728e-05
spk7_cr$chain_1$MAP$layer.params$layer_3$phi #7.829093e-05
spk7_cr$chain_1$MAP$layer.params$layer_4$phi #0.0002416741
spk7_cr$chain_1$MAP$layer.params$layer_5$phi #0.0002562059
spk7_cr$chain_1$MAP$layer.params$layer_6 #0.000283025
spk7_cr$chain_1$MAP$layer.params$layer_7 #0.00042711
